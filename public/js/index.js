import { CodePlayground } from "./codePlayground.js";
import { LayoutManager } from "./layoutManager.js";

(function () {
  const layout = new LayoutManager();
  layout.init();
  const code = new CodePlayground({
    html: JSON.parse(
      '"<canvas id=\\"gl\\"></canvas>\\n      <div class=\\"hud\\">\\n        WebGL2 Ocean — Gerstner Waves<br/>\\n        • 드래그: 카메라 회전 / 휠: 줌<br/>\\n        • 파라미터는 JS 상단에서 조절 가능\\n      </div>"'
    ),
    js: JSON.stringify('"// 러스트 모듈 초기화가 끝날 때까지 기다린다\\nconst rust = await window.__rust;\\nconsole.log(\'rust ok:\', rust);\\nconsole.log(\'add(2,3)=\', rust.add?.(2, 3));\\n\\n// ====== Config ======\\nconst GRID_RES = 256; // plane 분할 수 (256~512 권장, 성능에 맞춰 조절)\\nconst FOV = (55 * Math.PI) / 180;\\nconst CAMERA = { dist: 8.0, azim: Math.PI * 0.25, elev: 0.35 };\\nconst SUN_DIR = normalize([-0.5, 0.8, 0.2]); // 태양 방향\\nconst SUN_COLOR = [1.0, 0.95, 0.9];\\nconst WATER_BASE = [0.02, 0.16, 0.24]; // 심해색 베이스\\nconst SKY_TOP = [0.08, 0.23, 0.45];\\nconst SKY_HORZ = [0.4, 0.58, 0.8];\\n\\n// Gerstner 파도 파라미터(최대 4개 사용)\\nconst WAVES = [\\n  // dir(x,z), amplitude, wavelength, speed, steepness\\n  {\\n    dir: normalize([1.0, 0.4]),\\n    amp: 0.18,\\n    lambda: 4.0,\\n    speed: 1.0,\\n    steep: 0.75,\\n  },\\n  {\\n    dir: normalize([0.7, -1.0]),\\n    amp: 0.1,\\n    lambda: 2.2,\\n    speed: 1.4,\\n    steep: 0.75,\\n  },\\n  {\\n    dir: normalize([-0.8, 0.2]),\\n    amp: 0.06,\\n    lambda: 1.1,\\n    speed: 1.8,\\n    steep: 0.7,\\n  },\\n  {\\n    dir: normalize([0.2, 1.0]),\\n    amp: 0.03,\\n    lambda: 0.6,\\n    speed: 2.2,\\n    steep: 0.65,\\n  },\\n];\\n\\n// ====== WebGL bootstrap ======\\nconst canvas = document.getElementById(\\"gl\\");\\nconst gl = canvas.getContext(\\"webgl2\\", { antialias: true });\\nif (!gl) {\\n  alert(\\"WebGL2를 지원하지 않습니다.\\");\\n}\\n\\n// Resize\\nfunction fit() {\\n  const dpr = Math.min(2, window.devicePixelRatio || 1);\\n  const w = Math.floor(canvas.clientWidth * dpr);\\n  const h = Math.floor(canvas.clientHeight * dpr);\\n  if (canvas.width !== w || canvas.height !== h) {\\n    canvas.width = w;\\n    canvas.height = h;\\n  }\\n  gl.viewport(0, 0, canvas.width, canvas.height);\\n}\\nfunction onResize() {\\n  canvas.style.width = \\"100%\\";\\n  canvas.style.height = \\"100%\\";\\n  fit();\\n}\\nwindow.addEventListener(\\"resize\\", onResize);\\nonResize();\\n\\n// ====== Shaders ======\\nconst vertSrc = `#version 300 es\\nprecision highp float;\\n\\nlayout(location=0) in vec2 a_pos; // grid on XZ plane (unit)\\nuniform mat4 u_proj, u_view;\\nuniform float u_time;\\nuniform vec3 u_wavesDir[4];\\nuniform float u_wavesAmp[4];\\nuniform float u_wavesLambda[4];\\nuniform float u_wavesSpeed[4];\\nuniform float u_wavesSteep[4];\\nuniform int u_waveCount;\\n\\nout vec3 v_worldPos;\\nout vec3 v_worldNormal;\\nout float v_choppy;  // for foam cue\\n\\n// Gerstner helpers\\n// Given base position p (x,z, y=0), apply N waves (analytic)\\nvec3 gerstnerDisplace(vec3 p, out vec3 normal, out float choppy) {\\n  // Start with flat normal up\\n  vec3 n = vec3(0.0, 1.0, 0.0);\\n  vec3 pos = p;\\n  choppy = 0.0;\\n\\n  for (int i=0; i<4; ++i) {\\n    if (i >= u_waveCount) break;\\n    vec2 D = normalize(u_wavesDir[i].xz);\\n    float A = u_wavesAmp[i];\\n    float L = u_wavesLambda[i];\\n    float S = u_wavesSpeed[i];\\n    float steep = u_wavesSteep[i];\\n\\n    float k = 2.0 * 3.14159265 / L; // wave number\\n    float w = sqrt(9.81 * k);       // deep water dispersion (approx), can scale\\n    float phase = k * dot(D, p.xz) - (w * S) * u_time;\\n\\n    float cosP = cos(phase);\\n    float sinP = sin(phase);\\n\\n    // Horizontal choppiness via steepness\\n    pos.x += (steep * A) * D.x * cosP;\\n    pos.z += (steep * A) * D.y * cosP;\\n\\n    // Vertical displacement\\n    pos.y += A * sinP;\\n\\n    // Normal using partial derivatives of Gerstner (analytic)\\n    // See Tessendorf notes / Gerstner formulation\\n    vec3 tx = vec3(1.0\\n      - (steep * A * k) * D.x * D.x * sinP,\\n      A * k * D.x * cosP,\\n      - (steep * A * k) * D.x * D.y * sinP);\\n\\n    vec3 tz = vec3(\\n      - (steep * A * k) * D.x * D.y * sinP,\\n      A * k * D.y * cosP,\\n      1.0 - (steep * A * k) * D.y * D.y * sinP);\\n\\n    // Combine normals by TBN cross (approx accumulate)\\n    n += normalize(cross(tz, tx));\\n\\n    // For foam cue: large slopes / crests\\n    choppy += (steep * A * k) * abs(cosP);\\n  }\\n\\n  normal = normalize(n);\\n  return pos;\\n}\\n\\nvoid main() {\\n  // Place grid in world space, scale to cover area\\n  // a_pos in [-1,1]x[-1,1] -> scale to tile of size 40 (adjust as needed)\\n  vec2 tile = a_pos * 20.0;\\n  vec3 base = vec3(tile.x, 0.0, tile.y);\\n\\n  float c;\\n  vec3 N;\\n  vec3 worldPos = gerstnerDisplace(base, N, c);\\n\\n  v_worldPos = worldPos;\\n  v_worldNormal = N;\\n  v_choppy = c;\\n\\n  gl_Position = u_proj * u_view * vec4(worldPos, 1.0);\\n}\\n`;\\n\\nconst fragSrc = `#version 300 es\\nprecision highp float;\\n\\nin vec3 v_worldPos;\\nin vec3 v_worldNormal;\\nin float v_choppy;\\n\\nout vec4 o_color;\\n\\nuniform vec3 u_camPos;\\nuniform vec3 u_sunDir;\\nuniform vec3 u_sunColor;\\nuniform vec3 u_waterBase;\\nuniform vec3 u_skyTop;\\nuniform vec3 u_skyHorz;\\n\\nuniform float u_time;\\n\\n// Utility\\nfloat saturate(float x){ return clamp(x,0.0,1.0); }\\nvec3  saturate(vec3 v){ return clamp(v,vec3(0.0),vec3(1.0)); }\\n\\n// Schlick Fresnel\\nfloat fresnelSchlick(float cosTheta, float F0){\\n  return F0 + (1.0-F0)*pow(1.0 - cosTheta, 5.0);\\n}\\n\\n// Simple sky gradient for reflections\\nvec3 skyColor(vec3 dir){\\n  float t = saturate(dir.y*0.5 + 0.5);\\n  return mix(u_skyHorz, u_skyTop, t);\\n}\\n\\nvoid main(){\\n  vec3 N = normalize(v_worldNormal);\\n  vec3 V = normalize(u_camPos - v_worldPos);\\n  vec3 L = normalize(u_sunDir);\\n  vec3 H = normalize(L + V);\\n\\n  // Fresnel\\n  float cosV = saturate(dot(N, V));\\n  float F = fresnelSchlick(cosV, 0.04); // dielectric water ~0.02-0.06\\n\\n  // Reflection (env)\\n  vec3 R = reflect(-V, N);\\n  vec3 env = skyColor(R);\\n\\n  // Base water color (absorption tint) & diffuse (very subtle)\\n  vec3 base = u_waterBase;\\n  float NdotL = saturate(dot(N, L));\\n  vec3 diffuse = base * (0.08 + 0.22 * NdotL);\\n\\n  // Specular highlight\\n  float spec = pow(saturate(dot(N, H)), 120.0) * (0.35 + 0.65 * NdotL);\\n  vec3 specular = u_sunColor * spec;\\n\\n  // Foam at crests: use slope cue + facing\\n  float foamCrest = saturate(v_choppy * 0.08 - 0.15);\\n  float facing = 1.0 - cosV; // more foam when seen grazing\\n  float foam = saturate(foamCrest * (0.3 + 0.7 * facing));\\n\\n  // Small sparkle/foam flicker (cheap)\\n  float flick = fract(sin(dot(v_worldPos.xz, vec2(12.9898,78.233))) * 43758.5453);\\n  foam *= smoothstep(0.4, 1.0, flick + 0.15*sin(u_time*1.7 + v_worldPos.x*0.2));\\n\\n  // Combine: reflection via Fresnel, plus base/foam/spec\\n  vec3 color = mix(diffuse, env, F) + specular + foam*vec3(0.9,0.95,1.0);\\n\\n  // Simple distance fog\\n  float dist = length(u_camPos - v_worldPos);\\n  float fog = saturate(1.0 - exp(-0.02 * dist));\\n  vec3 fogCol = mix(u_skyHorz, u_skyTop, 0.5);\\n  color = mix(color, fogCol, fog*0.35);\\n\\n  o_color = vec4(saturate(color), 1.0);\\n}\\n`;\\n\\n// ====== GL helpers ======\\nfunction compileShader(type, src) {\\n  const sh = gl.createShader(type);\\n  gl.shaderSource(sh, src);\\n  gl.compileShader(sh);\\n  if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {\\n    console.error(gl.getShaderInfoLog(sh));\\n    throw new Error(\\"Shader compile failed\\");\\n  }\\n  return sh;\\n}\\nfunction createProgram(vs, fs) {\\n  const p = gl.createProgram();\\n  gl.attachShader(p, vs);\\n  gl.attachShader(p, fs);\\n  gl.linkProgram(p);\\n  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {\\n    console.error(gl.getProgramInfoLog(p));\\n    throw new Error(\\"Program link failed\\");\\n  }\\n  return p;\\n}\\nfunction normalize(v) {\\n  const l = Math.hypot(...v);\\n  return v.map((x) => x / l);\\n}\\n\\n// ====== Geometry: indexed grid on XZ [-1,1]^2 ======\\nfunction makeGrid(N) {\\n  const verts = new Float32Array((N + 1) * (N + 1) * 2);\\n  let k = 0;\\n  for (let j = 0; j <= N; j++) {\\n    for (let i = 0; i <= N; i++) {\\n      const x = (i / N) * 2 - 1;\\n      const z = (j / N) * 2 - 1;\\n      verts[k++] = x;\\n      verts[k++] = z;\\n    }\\n  }\\n  const indices = new Uint32Array(N * N * 6);\\n  let t = 0;\\n  for (let j = 0; j < N; j++) {\\n    for (let i = 0; i < N; i++) {\\n      const a = j * (N + 1) + i;\\n      const b = a + 1;\\n      const c = a + (N + 1);\\n      const d = c + 1;\\n      indices[t++] = a;\\n      indices[t++] = c;\\n      indices[t++] = b;\\n      indices[t++] = b;\\n      indices[t++] = c;\\n      indices[t++] = d;\\n    }\\n  }\\n  return { verts, indices };\\n}\\nconst grid = makeGrid(GRID_RES);\\n\\n// ====== Program & buffers ======\\nconst prog = createProgram(\\n  compileShader(gl.VERTEX_SHADER, vertSrc),\\n  compileShader(gl.FRAGMENT_SHADER, fragSrc)\\n);\\ngl.useProgram(prog);\\n\\nconst vao = gl.createVertexArray();\\ngl.bindVertexArray(vao);\\n\\nconst vbo = gl.createBuffer();\\ngl.bindBuffer(gl.ARRAY_BUFFER, vbo);\\ngl.bufferData(gl.ARRAY_BUFFER, grid.verts, gl.STATIC_DRAW);\\ngl.enableVertexAttribArray(0);\\ngl.vertexAttribPointer(0, 2, gl.FLOAT, false, 8, 0);\\n\\nconst ibo = gl.createBuffer();\\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);\\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, grid.indices, gl.STATIC_DRAW);\\n\\n// Uniform locations\\nconst loc = (name) => gl.getUniformLocation(prog, name);\\nconst u_proj = loc(\\"u_proj\\");\\nconst u_view = loc(\\"u_view\\");\\nconst u_time = loc(\\"u_time\\");\\nconst u_camPos = loc(\\"u_camPos\\");\\nconst u_sunDir = loc(\\"u_sunDir\\");\\nconst u_sunColor = loc(\\"u_sunColor\\");\\nconst u_waterBase = loc(\\"u_waterBase\\");\\nconst u_skyTop = loc(\\"u_skyTop\\");\\nconst u_skyHorz = loc(\\"u_skyHorz\\");\\n\\nconst u_wavesDir = loc(\\"u_wavesDir\\");\\nconst u_wavesAmp = loc(\\"u_wavesAmp\\");\\nconst u_wavesLambda = loc(\\"u_wavesLambda\\");\\nconst u_wavesSpeed = loc(\\"u_wavesSpeed\\");\\nconst u_wavesSteep = loc(\\"u_wavesSteep\\");\\nconst u_waveCount = loc(\\"u_waveCount\\");\\n\\n// Upload static uniforms\\ngl.uniform3fv(u_sunDir, SUN_DIR);\\ngl.uniform3fv(u_sunColor, SUN_COLOR);\\ngl.uniform3fv(u_waterBase, WATER_BASE);\\ngl.uniform3fv(u_skyTop, SKY_TOP);\\ngl.uniform3fv(u_skyHorz, SKY_HORZ);\\n\\n// Waves\\nconst WN = Math.min(4, WAVES.length);\\nconst wavesDirArr = new Float32Array(4 * 3); // xyz (use xz)\\nconst wavesAmpArr = new Float32Array(4);\\nconst wavesLamArr = new Float32Array(4);\\nconst wavesSpdArr = new Float32Array(4);\\nconst wavesStpArr = new Float32Array(4);\\nfor (let i = 0; i < 4; i++) {\\n  const w = WAVES[i] || { dir: [1, 0], amp: 0, lambda: 1, speed: 0, steep: 0 };\\n  wavesDirArr.set([w.dir[0], 0, w.dir[1]], i * 3);\\n  wavesAmpArr[i] = w.amp;\\n  wavesLamArr[i] = w.lambda;\\n  wavesSpdArr[i] = w.speed;\\n  wavesStpArr[i] = w.steep;\\n}\\ngl.uniform3fv(u_wavesDir, wavesDirArr);\\ngl.uniform1fv(u_wavesAmp, wavesAmpArr);\\ngl.uniform1fv(u_wavesLambda, wavesLamArr);\\ngl.uniform1fv(u_wavesSpeed, wavesSpdArr);\\ngl.uniform1fv(u_wavesSteep, wavesStpArr);\\ngl.uniform1i(u_waveCount, WN);\\n\\n// ====== Camera & matrices ======\\nfunction perspective(fovy, aspect, near, far) {\\n  const f = 1 / Math.tan(fovy / 2),\\n    nf = 1 / (near - far);\\n  const out = new Float32Array(16);\\n  out[0] = f / aspect;\\n  out[5] = f;\\n  out[10] = (far + near) * nf;\\n  out[11] = -1;\\n  out[14] = 2 * far * near * nf;\\n  return out;\\n}\\nfunction lookAt(eye, target, up) {\\n  const z = normalize3(sub3(eye, target));\\n  const x = normalize3(cross(up, z));\\n  const y = cross(z, x);\\n  const m = new Float32Array(16);\\n  m[0] = x[0];\\n  m[1] = y[0];\\n  m[2] = z[0];\\n  m[3] = 0;\\n  m[4] = x[1];\\n  m[5] = y[1];\\n  m[6] = z[1];\\n  m[7] = 0;\\n  m[8] = x[2];\\n  m[9] = y[2];\\n  m[10] = z[2];\\n  m[11] = 0;\\n  m[12] = -dot(x, eye);\\n  m[13] = -dot(y, eye);\\n  m[14] = -dot(z, eye);\\n  m[15] = 1;\\n  return m;\\n}\\nfunction sub3(a, b) {\\n  return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\\n}\\nfunction cross(a, b) {\\n  return [\\n    a[1] * b[2] - a[2] * b[1],\\n    a[2] * b[0] - a[0] * b[2],\\n    a[0] * b[1] - a[1] * b[0],\\n  ];\\n}\\nfunction dot(a, b) {\\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\\n}\\nfunction len(a) {\\n  return Math.hypot(a[0], a[1], a[2]);\\n}\\nfunction normalize3(a) {\\n  const l = len(a) || 1;\\n  return [a[0] / l, a[1] / l, a[2] / l];\\n}\\n// function normalize(a) {\\n//   const l = Math.hypot(...a) || 1;\\n//   return a.map((v) => v / l);\\n// }\\n\\n// Orbit controls (마우스로 회전/줌)\\nlet isDrag = false,\\n  px = 0,\\n  py = 0;\\ncanvas.addEventListener(\\"mousedown\\", (e) => {\\n  isDrag = true;\\n  px = e.clientX;\\n  py = e.clientY;\\n});\\nwindow.addEventListener(\\"mouseup\\", () => (isDrag = false));\\nwindow.addEventListener(\\"mousemove\\", (e) => {\\n  if (!isDrag) return;\\n  const dx = (e.clientX - px) / canvas.clientWidth;\\n  const dy = (e.clientY - py) / canvas.clientHeight;\\n  CAMERA.azim -= dx * 3.0;\\n  CAMERA.elev = Math.max(-1.2, Math.min(1.2, CAMERA.elev - dy * 2.0));\\n  px = e.clientX;\\n  py = e.clientY;\\n});\\ncanvas.addEventListener(\\n  \\"wheel\\",\\n  (e) => {\\n    CAMERA.dist *= 1 + Math.sign(e.deltaY) * 0.08;\\n    CAMERA.dist = Math.max(2.5, Math.min(30.0, CAMERA.dist));\\n  },\\n  { passive: true }\\n);\\n\\n// ====== Render loop ======\\ngl.enable(gl.DEPTH_TEST);\\ngl.enable(gl.CULL_FACE);\\ngl.cullFace(gl.BACK);\\n\\nlet t0 = performance.now();\\nfunction frame() {\\n  fit();\\n  const t = (performance.now() - t0) / 1000;\\n\\n  gl.clearColor(0.02, 0.04, 0.08, 1);\\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\n\\n  // Camera\\n  const aspect = canvas.width / canvas.height;\\n  const proj = perspective(FOV, aspect, 0.01, 100.0);\\n\\n  // Spherical to Cartesian\\n  const ce = Math.cos(CAMERA.elev),\\n    se = Math.sin(CAMERA.elev);\\n  const ca = Math.cos(CAMERA.azim),\\n    sa = Math.sin(CAMERA.azim);\\n  const eye = [\\n    CAMERA.dist * ce * ca,\\n    Math.max(1.2, CAMERA.dist * se),\\n    CAMERA.dist * ce * sa,\\n  ];\\n  const view = lookAt(eye, [0, 0, 0], [0, 1, 0]);\\n\\n  gl.useProgram(prog);\\n  gl.uniformMatrix4fv(u_proj, false, proj);\\n  gl.uniformMatrix4fv(u_view, false, view);\\n  gl.uniform1f(u_time, t * 0.75);\\n  gl.uniform3fv(u_camPos, new Float32Array(eye));\\n\\n  gl.bindVertexArray(vao);\\n  gl.drawElements(gl.TRIANGLES, grid.indices.length, gl.UNSIGNED_INT, 0);\\n\\n  requestAnimationFrame(frame);\\n}\\nrequestAnimationFrame(frame);"'),
    css: JSON.parse(
      '"html,body { height:100%; margin:0; background:#0a0f18; overflow:hidden; }\\n      #gl { width:100%; height:100%; display:block; }\\n      .hud {\\n        position: fixed; left:12px; bottom:12px; color:#cbd5e1; font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;\\n        background: rgba(0,0,0,.35); padding:10px 12px; border:1px solid rgba(255,255,255,.08); border-radius:10px;\\n      }"'
    ),

    meta: `WebGL2 Ocean — Gerstner Waves`,
    rust: `
    use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
    `
  });
})();
